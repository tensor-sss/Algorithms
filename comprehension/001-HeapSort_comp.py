# 核心思想：将乱序的数组看成一个严格从上到下，从左到右排列的二叉树，即中间节点不包含缺失值
# 第一步：从最后一层的最后一个父节点开始，以从下到上的顺序，保证每一个父节点都比它的左右孩子节点大，这一步称之为大顶堆
# 第二步：经过前一步的操作，我们现在手上的二叉树的根节点已经保证是所有数里最大的，由于我们要将整个数组从小到大排序，所以我们将该
#       根节点移到二叉树的最低节点，也就是最后一层最后一个父节点的孩子节点
# 第三步：由于第二步打乱了这个相对次序，因此我们保留已经排好在最后一个位置上的最大的数，并对前面所有的数继续进行重排

# 我们先将整个数组传入函数
def HeapSort(l):

    # 首先我们遇到的第一个问题，如何找到最后一层的最后一个父节点？
    # 通过数学规律可以发现，这个值的位置总是在len(n) // 2 - 1 处
    # 并且由于我们要从下往上交换，于是可以确定，这个值就是我们遍历的起点
    # 终点也很好确定，因为我们要整个遍历一遍，所以要过0号位置，但是由于range是左闭右开的区间，所以我们要记得取到-1
    for i in range(len(l)//2-1, -1, -1):
        # 从这里开始我们要进行交换的逻辑，方便起见我们在这写一个新的函数
        shift(l, i, len(l) - 1) # 现在我们完成了大顶堆的步骤
    # 优化写法：for i in range(len(l)-1, 0, -1):
    for i in range(len(l)-1, -1, -1):
        # 将最大的值与最底端的节点进行交换
        l[0], l[i] = l[i], l[0]
        # 每一轮交换之后，只有“根节点（下标 0）”可能破坏堆性质，
        # 其他节点仍然是合法的大顶堆，所以只需要从 0 开始下沉
        shift(l,0, i - 1)

    return l


# 这里我们要传入数组l，起始值low,上限值high
def shift(l, low, high):
    # i 标记要调整的那个父节点
    i = low
    # j 标记该父节点的孩子节点
    j = 2 * i + 1 # 此处具体表示左孩子
    # 备份父节点的值
    temp = l[i]

    # 因为在完全二叉树中，一个非叶子节点一定存在左孩子，
    # 因此可以通过“左孩子是否存在”来作为筛选的终止条件；
    # 当一个节点不存在左孩子时，它一定是叶子节点，筛选过程必须终止。

    while j <= high:
        # j < high判断右孩子是否存在，然后比较左右孩子的大小
        if j < high and l[j] < l[j + 1]:
            # 当右孩子比左孩子大的时候才进来
            j = j + 1
        # 将较大的孩子和父节点比大小
        if temp < l[j]:
            # 如果孩子大就将父节点替换
            l[i] = l[j]
            # 把当前需要继续下沉（检测）的节点，移动到刚才选中的那个“较大的孩子节点”位置上
            i = j
            # 更新孩子节点
            j = 2 * i + 1
        else:
            # 当 temp 已经不小于当前层中最大的孩子时，
            # 继续下沉只会破坏堆性质而不会修复任何问题，
            # 因此可以立即终止，将 temp 放在当前位置
            break

    l[i] = temp

# AI总结：# 堆排序核心思想：
# # 1. 将数组视为完全二叉树，用数组下标隐式表示父子关系
# # 2. 自底向上对所有非叶子节点做 sift-down，建立大顶堆
# # 3. 此时堆顶（index 0）一定是当前范围内的最大值
# # 4. 将堆顶与当前堆的最后一个元素交换，该位置即为最终有序
# # 5. 交换后只有根节点可能破坏堆性质
# # 6. 因此只需从 index 0 开始，对剩余区间做一次 sift-down
# # 7. 重复缩小堆范围，直到堆大小为 1
# # 8. sift-down 的终止条件：当前节点不再有左孩子（到达叶子）
# # 9. 若父节点 ≥ 当前层最大孩子，则下方子堆已满足堆性质，可提前终止
# # 10. 整个过程原地完成，时间复杂度 O(n log n)，空间复杂度 O(1)

# 测试
if __name__ == '__main__':
    l1 = [43, 12, 64, 35, 867, 23, 75, 18, 42]
    res = HeapSort(l1)
    print(res)



